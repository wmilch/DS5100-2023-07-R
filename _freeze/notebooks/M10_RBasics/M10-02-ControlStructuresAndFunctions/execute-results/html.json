{
  "hash": "2adf0c75b28fc91393f50e2a17992c03",
  "result": {
    "markdown": "---\neditor: \n  markdown: \n    wrap: 72\n---\n\n\n# NB: Control Structures and Functions\n\n## `if`/`else` Statements\n\nYou've seen this in Python.\n\nThey work the same way in both languages.\n\nHere's their syntax in R.\n\n```         \nif(<condition>) {\n        ## do something\n} \n\nif(<condition>) {\n        ## do something\n} \nelse {\n        ## do something else\n}\n\nif(<condition1>) {\n        ## do something\n} else if(<condition2>)  {\n        ## do something different\n} else {\n        ## do something different\n}\n```\n\nGenerate a uniform random number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- runif(1, 0, 10) # From the Uniform Distribution\n\nif(x > 3) {\n  y <- 10\n} else {\n  y <- 0\n}\n\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8.408442\n```\n:::\n\n```{.r .cell-code}\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\nYou assign an `if` statement to a variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- if(x > 3) {\n  10\n} else { \n  0\n}\n\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\nYou can stack `if` blocks, too.\n\n```         \nif(<condition1>) {\n\n}\n\nif(<condition2>) {\n\n}\n```\n\n## Control Structures\n\n### `for` Loops\n\nFor loops are straight-forward. The take an interator variable, e.g.\n`i`, and assign it successive values from a sequence or vector.\n\nFor loops are often used to iteratE over the elements of an object\n(list, vector, etc.).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:10) {\n  print(i)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n```\n:::\n:::\n\n\nAccording to Hadley Wickham, loops are pretty much the only looping\nconstruct that you will need in R.\n\nThe following three loops all have the same behavior.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(\"a\", \"b\", \"c\", \"d\")\nfor (i in 1:4) {\n  # Print out each element of 'x'\n  print(x[i])  \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\n### `seq_along()`\n\nThe `seq_along()` function is commonly used in conjunction with for\nloops in order to generate an integer sequence based on the length of an\nobject (in this case, the object x).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"c\" \"d\"\n```\n:::\n:::\n\n\nGenerate a sequence based on length of 'x':\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in seq_along(x)) {   \n  print(x[i])\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nIt is not necessary to use an index-type variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(letter in x) {\n  print(letter)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\nFor one line loops, the curly braces are not strictly necessary.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:4) print(x[i])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\"\n[1] \"b\"\n[1] \"c\"\n[1] \"d\"\n```\n:::\n:::\n\n\n### Nested `for` loops\n\nDor loops can be nested inside of each other.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- matrix(1:6, 2, 3)\nfor(i in seq_len(nrow(x))) {\n  for(j in seq_len(ncol(x))) {\n    print(x[i, j])\n  }   \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 3\n[1] 5\n[1] 2\n[1] 4\n[1] 6\n```\n:::\n:::\n\n\nNested loops are used to generate multidimensional or hierarchical data\nstructures (e.g. matrices, lists).\n\n## `while` Loops\n\nAs with Python, while loops start with a condition. It loops while the\ncondition is true and stops when it is false.\n\nRemembe, while loops can go on forever is the truth condition is never\nmet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount <- 0\nwhile(count < 10) {\n  print(count)\n  count <- count + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n```\n:::\n:::\n\n\n## `repeat` Loops\n\n`repeat` loops are using by R. They initiate an infinite loop right from\nthe start.\n\nThe only way to exit a repeat loop is to call break on an internal\ncondition.\n\n\n\n\n\n## `next` and `break`\n\nnext is used to skip an iteration of a loop. Same as Python `continue`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:100) {\n  if (i <= 20) {\n    # Skip the first 20 iterations\n    next                \n  }      # Do something here\n}\n```\n:::\n\n\n`break` is used to exit a loop immediately.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in 1:100) {\n  print(i)\n  if (i > 20) {\n    # Stop loop after 20 iterations\n    break  \n  }     \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n[1] 5\n[1] 6\n[1] 7\n[1] 8\n[1] 9\n[1] 10\n[1] 11\n[1] 12\n[1] 13\n[1] 14\n[1] 15\n[1] 16\n[1] 17\n[1] 18\n[1] 19\n[1] 20\n[1] 21\n```\n:::\n:::\n\n\n## Functions\n\nDefine some data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 5                \nxx <- c(4, 6, 7, 8, 2, 11)\n```\n:::\n\n\nNow, define a function that does the following: - takes a value, vector\nof values as inputs - normalizes the value against the vector by\nsubtracting the vector mean from value, and dividing by vector standard\ndeviation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_zscore <- function(val, vec) {\n  z <- (val - mean(vec)) / sd(vec)\n}\n\nprint(compute_zscore(x, xx))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.4244764\n```\n:::\n:::\n\n\nIf vector contains identical values, `sd` is zero, and so the z-score is\nundefined.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(compute_zscore(x, c(1, 1, 1, 1)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n:::\n\n\nIf vector contains missing values, the result will be `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxx_na <- c(1, NA, 3, 5) \nprint(compute_zscore(x, xx_na))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\n## Using conditions in functions\n\nA function returns 1 if passed value is odd, 0 if even\n\n## %% is mod operator (returns remainder)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_odd <- function(x){ if (x %% 2 == 1) { \n    return(1) \n  } else { \n    return(0)\n  } \n}\n```\n:::\n\n\nCall to test some cases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_odd(4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nis_odd(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n\nFunction arguments can use default values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthreshold_vals <- function(p, thresh = 0.5) {\n  # for each element in p, returns TRUE if value > thresh, else FALSE\n  p > thresh\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nthreshold_vals(c(0.6, 0.4, 0.1, 1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE FALSE FALSE  TRUE\n```\n:::\n:::\n\n\nNow, pass a threshhold:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthreshold_vals(c(0.6, 0.4, 0.1, 1), 0.7)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE FALSE  TRUE\n```\n:::\n:::\n\n\nAssert important preconditions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_vectors <- function(x, y) {\n  # assert the lengths of vectors x and y match\n  # if they do, sum elementwise, else throw error with stop()\n\n  if (length(x) != length(y)) {\n    stop(\"x and y must be the same length\", call. = FALSE)\n  }\n  x + y\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_vectors(c(1, 2, 3), c(3, 3, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 5 6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadd_vectors(c(1, 2, 3), c(3, 3, 3, 3)) # breaks\n```\n:::\n\n\n## Scoping Rules\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- 4\ntest_fcn <- function(x) {\n  x^z\n}\n```\n:::\n\n\nNow look at this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntest_fcn(2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n:::\n\n\nIf `z` isn't defined in the function, how does this work?\n\nR's scoping rules are similar to Python's.\n\nSince `z` isn't in the function, **R looks in the function's\nenvironment** for it.\n\nFor more on scoping rules, see [Chapter 15: Scoping Rules of\nR](https://bookdown.org/rdpeng/rprogdatascience/scoping-rules-of-r.html)\nin Peng's *R Programming For Data Science*.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}